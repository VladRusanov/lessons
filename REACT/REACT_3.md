# функциональные компоненты React (пока без хуков)

Функциональные компоненты - компоненты React, которые нужены для отображения чего-то на страницу (без какой-то сложной логики). 

!!! Мы пока не берем во внимание функции с хуками !!!

```
./Main.jsx

import React from 'react';

const Main = () => {
    return (
        <div>
            <span>hello</span>
        </div>
    )
}

export default Main;

```
Вызов компонента

```
./App.jsx

class App extends React.Component {
  render() {
    return (
      <div>
        <Main />
      </div>
    )
  }
}

```

Теперь пример на пропсы

```
import React from 'react';

const Main = (props) => {
    return (
        <div>
            <span>{props.text}</span>
        </div>
    )
}

export default Main;

```

```
class App extends React.Component {
  render() {
    return (
      <div>
        <Main text="Text"/>
      </div>
    )
  }
}

```


# Условный рендеринг

React позволяет разделить логику на независимые компоненты. Эти компоненты можно показывать или прятать в зависимости от текущего состояния.

Условный рендеринг в React работает так же, как условные выражения работают в JavaScript.

```
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isOpen: false
    }
  }

  toggleOpen = () => {
    this.setState((prevState) => ({
      isOpen: !prevState.isOpen
    }));
  }

  componentDidMount() {
    this.toggleOpen();
  }

  render() {
    return (
      <div>
        {this.state.isOpen ? (
          <div>Open</div>
        ) : (
          <div>Close</div>
        )}
      </div>
    )
  }
}

```

Также можно комбинировать с компонентами

```
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isLoggedIn: false
    }
  }

  signIn = () => {
    this.setState({
      isLoggedIn: true
    });
  }

  componentDidMount() {
    this.signIn();
  }

  spawnForm = () => {
    const { isLoggedIn } = this.state;
    if (isLoggedIn) {
      return <AppForm />
    }
    return <SignInFrom />
  }

  render() {
    return (
      <div>
        {this.spawnForm()}
      </div>
    )
  }
}

```


# Проблема DOM

Главная проблема DOM — он никогда не был рассчитан для создания динамического пользовательского интерфейса (UI)


# Виртуальный DOM

Что такое виртуальный DOM?

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM.

Такой подход и делает API React декларативным: вы указываете, в каком состоянии должен находиться пользовательский интерфейс, а React добивается, чтобы DOM соответствовал этому состоянию.


Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. 

Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.

При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.

Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.

Есть две проблемы: когда именно делать повторную перерисовку DOM и как это сделать эффективно.

# Когда?

Когда данные изменяются и нуждается в обновлении.

Есть два варианта узнать, что данные изменились:

- Первый из них — «dirty checking» (грязная проверка) заключается в том, чтобы опрашивать данные через регулярные промежутки времени и рекурсивно проверять все значения в структуре данных.

- Второй вариант — «observable» (наблюдаемый) заключается в наблюдении за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, мы точно знаем, что нужно обновить.

# Как?

Что делает этот подход действительно быстрым:

- Эффективные алгоритмы сравнения

- Группировка операций чтения/записи при работе с DOM

- Эффективное обновление только под-деревьев


# SPA (single page application)

На React пишутся SPA приложения

Что такое одностраничное приложение?

Приложение SPA - это буквально одна страница, которая постоянно взаимодействует с пользователем, динамически переписывая текущую страницу, а не загружая целые новые страницы с сервера

# Преимущества Single Page Applications

- Доступность. Можно получить моментальный доступ к функционалу с любого типа устройства без проблем с совместимостью, объемом памяти, мощностями или временем на установку.

- Универсальность. Использовать софт можно практически с любого устройства, если на нем есть доступ к интернету. Если при разработке интерфейса учитывались различные разрешения 
экрана, то использовать SPA одинаково удобно и с ПК и со смартфона.

- Возможность задействовать большие объемы данных. Размер приложения и используемых им данных не ограничен памятью устройства.

- Скорость. Одна страницасо всем необходимым не только экономит время на повторную загрузку данных, но и повышает производительность работы.

- Возможности разработки. Разработчикам доступны фреймворки, которые упрощают создание архитектуры проекта и предоставляют немало готовых элементов для работы.

# Недостатки SPA

- Трудности с SEO. Особенности SPA усложняют или делают невозможным процесс индексации поисковыми системами всех модулей приложения. Это может вызвать трудности с оптимизацией.

- Не работает у пользователей с отключенной поддержкой JS. Многие отключают отображение JS-элементов у себя в браузерах, а Single Page Application использует их в работе, поэтому может не работать.

# Списки и ключи

Сначала давайте вспомним, как работать со списками в JavaScript.

```
const arr = [1,2,3,4];
const newArr = arr.map(item => item + 1);

console.log(newArr); // [2,3,4,5]

```

В React преобразование массивов в список элементов выглядит похожим образом.


# Рендер нескольких компонентов

Вы можете создать коллекцию элементов и встроить её в JSX с помощью фигурных скобок {}.

К примеру

```
class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a','b','c','d'];
        return arr.map(letter => {
            return (
                <span>{letter}</span>
            )
        })
    }
    
    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

Когда вы запустите данный код, то увидите предупреждение о том, что у каждого элемента массива должен быть ключ (key). «Ключ» — это специальный строковый атрибут, который нужно указывать при создании списка элементов

Чтобы исправить проблему с неуказанными ключами, добавим каждому элементу в списке атрибут key.

```
class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a','b','c','d'];
        return arr.map(letter => {
            return (
                <span key={letter}>{letter}</span>
            )
        })
    }
    
    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

# Ключи

Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. 

Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. 

Чаще всего вы будете использовать ID из ваших данных как ключи:

Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ:

```
class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a','b','c','d'];
        return arr.map((letter, index) => {
            return (
                <span key={index}>{letter}</span>
            )
        })
    }
    
    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

# Извлечение компонентов с ключами

Ключи нужно определять непосредственно внутри массивов. (внутри перебора)

```
./Span.jsx

class Span extends Component {
    render() {
        return (
            <span>{this.props.value}</span> // ! key передаем не сюда !
        )
    }
}

```

```
./Test.jsx

class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a', 'b', 'c', 'd'];
        return arr.map((letter, index) => {
            return <Span value={letter} key={index} /> // ! Key нужен тут !
        })
    }

    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

!!!! Ключи должны быть уникальными !!!!


# Роутинг ( Маршрутизация )

Для чего нужна маршрутизация?

В любом реальном веб-приложении нужны маршруты, и приложение React не исключение. 

Пользователь должен видеть, где он находится в приложении в любой момент времени. 

А видит он свое текущее местоположение в адресной строке браузера. 

Следовательно приложение должно уметь сопоставлять определённый URL с соответствующей ему страницей. 

То есть, если мы введём в адресную строку например https://test/test1, то приложение должно направить нас на страницу списка приёмов, но не на какую-либо другую.

Также должна работать история. 

То есть когда пользователь кликает на стрелку "Назад" в браузере, приложение должно направить нас на предыдущую страницу.

Сам по себе React не предоставляет такой возможности, это задача специальных библиотек. 

Как правило, используя API такой библиотеки мы подключаем компоненты страниц нашего положения, сопоставляя их с определёнными путями. 

После этого, переходя с одной страницы на другую мы будем видеть в адресной строке, как изменяется текущий путь.

На данный момент есть несколько популярных библиотек для маршрутизации: react-router, router5, aviator и пр. 

Мы будем использовать **react-router**

# Библиотека react-router

Эта библиотека популярна, довольна проста в использовании и обладает хорошей документацией.

Она предоставляет такие возможности как:

- Навигация по клику (компонент <Link>)

- Перенаправление (компонент <Redirect>)

- Маршрутизация (компонент Route)

- История (свойство history)

# Установка

React Router был разбит на 3 пакета:

- react-router

- router-dom

- react-router-native

Мы будем создавать сайт который будет отображаться в браузере, поэтому нам следует использовать react-router-dom. react-router-dom экспортирует из react-router все функции поэтому нам нужно установить только react-router-dom.

```
npm install --save react-router-dom

```

# Router

При старте проекта вам нужно определить какой тип роутера использовать. 

Для браузерных проектов есть BrowserRouter и HashRouter компоненты. 

BrowserRouter — следует использовать когда вы обрабатываете на сервере динамические запросы, а HashRouter используйте когда у вас статический веб сайт.

Обычно предпочтительнее использовать BrowserRouter, но если ваш сайт расположен на статическом сервере(от перев. как github pages), то использовать HashRouter это хорошее решение проблемы.

Если проект предполагает использование бекенда, то будем использовать BrowserRouter.

# История — History

Каждый Router создает объект history который хранит путь к текущему location и перерисовывает интерфейс сайта когда происходят какие то изменения пути.


# Начало работы 

В начале для работы с маршрутами также получаем ряд объектов, которые потребуются для определения маршрутов:

```
import { BrowserRouter, Route, Switch } from 'react-router-dom'

```

Здесь определены три объекта из модуля react-router-dom.

Router определяет набор маршрутов и, когда к приложению, приходит запрос, то Router выполняет сопоставление запроса с маршрутами. 

И если какой-то маршрут совпадает с URL запроса, то этот маршрут выбирается для обработки запроса.

И также для выбора маршрута определен объект Switch. 

Он позволяет выбрать первый попавшийся маршрут и его использовать для обработки. 

Без этого объекта Router может использовать для обработки одного запроса теоретически несколько маршрутов, если они соответствуют строке запроса.

Каждый маршрут представляет объект Route. 

Он имеет ряд атрибутов. В частности, здесь для маршрута устанавливаются два атрибута:

- path: шаблон адреса, с которым будет сопоставляться запрошенный адрес URL

- component - тот компонент, который отвечает за обработку запроса по этому маршруту


Причем в данном случае один маршрут выступает в качестве корневого. Он сопоставляется с адресом "/" и определен компонентом Main (в нашем случае)

```
<Route exact path="/" component={Main} /> 

```

Стоит отметить, что данный маршрут использует квалификатор exact. 

Этот квалификатор допускает только точное совпадение маршрута со строкой запроса. 

Например, строка запроса может представлять путь "/" или путь "/about" или путь "/contact/dsdf", и все эти пути будут соответствовать маршруту с шаблоном адреса "/". 

То есть маршруту, который обрабатывается компонентом Main. 

Но слово exact позволяет рассматривать точное совпадение, то есть когда шаблону "/" соответствует только строка запроса "/".


Второй маршрут будет сопоставляться с адресом "/about", а обрабатываться он будет компонентом About.

```
<Route path="/about" component={About} />

```

Особо следует выделить третий маршрут:

```
<Route component={NotFound} />

```

Этот маршрут будет сопоставляться со всеми адресами URL, которые не соответствуют предыдущим маршрутам. И он будет обрабатываться компонентом NotFound.


# Полный пример

```
import React from 'react'
import { BrowserRouter, Route, Switch } from 'react-router-dom'

import Second from './components/SecondPage.jsx'
import First from './components/FirstPage.jsx'
import Main from './components/MainPage.jsx'
import './App.css'

class App extends React.Component {
  render() {
    return (
      <BrowserRouter>
        <Switch>
          <Route exact path="/" component={Main} /> // Компонент, который рендерится по умолчанию
          <Route exact path="/first" component={First} /> // Если в поисковой строке будет /first, то на странице будет компонент First
          <Route exact path="/second" component={Second} /> // Если в поисковой строке будет /second, то на странице будет компонент Second
        </Switch>
      </BrowserRouter>
    )
  }
}

export default App

```


# Как же переходить по этим роутам

Переход происходит по ссылка, но использовать тег <a> очень плохо. Это будет вызывать переренд приложения.

В React для этого есть своя ссылка - <Link>

<Link> - принимает аттрибут to
    
Аттрибут to - принимает строку. При нажатии на этот Link мы перейдем на тот роут, который вписан в аттрибут to

```
import React from 'react';
import { Link } from 'react-router-dom'

class Main extends React.Component {
    render() {
        return (
            <div>
                <Link to='/first'>При нажатии перейдем по маршруту - /first </Link>
                <Link to='/second'>При нажатии перейдем по маршруту - /second </Link>
                
                /*
                 При нажатии на <Link> меняется path в адрессной строке
                 На изменения в адрессной строке реагирует роутер (который у нас описан в App)
                */
            </div>
        )
    }
}


export default Main;

```


# Рефы и DOM


Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе.
    
# Когда использовать рефы

Ситуации, в которых использование рефов является оправданным:

- Управление фокусом, выделение текста или воспроизведение медиа.

- Императивный вызов анимаций.

- Интеграция со сторонними DOM-библиотеками.
    
!!!!!! Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом. !!!!!!

# Создание рефов

Рефы создаются с помощью React.createRef() и прикрепляются к React-элементам через ref атрибут. 

Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента.

```
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}

```

# Доступ к рефам

Когда реф передаётся элементу в методе render, ссылка на данный узел доступна через свойство рефа current.

```
const node = this.myRef.current;

```

# Значение рефа отличается в зависимости от типа узла:

- Когда атрибут ref используется с HTML-элементом, свойство current созданного рефа в конструкторе с помощью React.createRef() получает соответствующий DOM-элемент.

- Когда атрибут ref используется с классовым компонентом, свойство current объекта-рефа получает экземпляр смонтированного компонента.

- Нельзя использовать ref атрибут с функциональными компонентами, потому что для них не создаётся экземпляров.


# Добавление рефа к DOM-элементу

В представленном ниже примере ref используется для хранения ссылки на DOM-элемент и установки фокуса в инпут.

```
class Main extends React.Component {
    constructor(props) {
        super(props);
        // создадим реф в поле `textInput` для хранения DOM-элемента
        this.textInput = React.createRef();
    }

    focusTextInput() {
        // Установим фокус на текстовое поле с помощью чистого DOM API
        // Примечание: обращаемся к "current", чтобы получить DOM-узел
        this.textInput.current.focus();
    }

    componentDidMount() {
        this.focusTextInput()
    }

    render() {
        // описываем, что мы хотим связать реф <input>
        // с `textInput` созданным в конструкторе
        return (
            <div>
                <input type="text" ref={this.textInput} />
            </div>
        )
    }
}

```

# HomeWork

1) Создать 2 формы - SignIn, SignUp

Как только открываем наше приложение, то отображается форма SignIn.

С формы SignIn (по клику на кнопку "sign up", которая будет где-то внизу формы) мы можем перейти на форму SignUp

Дизайн делаем любой

2) Дам массив [{id: 1, name: 'Vasya', lasName: 'Test1'}, {id: 2, name: 'Vova', lasName: 'Test2'}, {id: 3, name: 'Petya', lasName: 'Test3'}]

Создать таблицу, в которой будет 2 колонки - имя, фамилия

В эту таблицу вставляем данные из массва

```
<table>
    ....
</table>

```
