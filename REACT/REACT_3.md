# Проблема DOM

Главная проблема DOM — он никогда не был рассчитан для создания динамического пользовательского интерфейса (UI)


# Виртуальный DOM

Что такое виртуальный DOM?

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM.

Такой подход и делает API React декларативным: вы указываете, в каком состоянии должен находиться пользовательский интерфейс, а React добивается, чтобы DOM соответствовал этому состоянию.


Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. 

Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.

При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.

Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.

Есть две проблемы: когда именно делать повторную перерисовку DOM и как это сделать эффективно.

# Когда?

Когда данные изменяются и нуждается в обновлении.

Есть два варианта узнать, что данные изменились:

- Первый из них — «dirty checking» (грязная проверка) заключается в том, чтобы опрашивать данные через регулярные промежутки времени и рекурсивно проверять все значения в структуре данных.

- Второй вариант — «observable» (наблюдаемый) заключается в наблюдении за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, мы точно знаем, что нужно обновить.

# Как?

Что делает этот подход действительно быстрым:

- Эффективные алгоритмы сравнения

- Группировка операций чтения/записи при работе с DOM

- Эффективное обновление только под-деревьев


# SPA (single page application)

На React пишутся SPA приложения

Что такое одностраничное приложение?

Приложение SPA - это буквально одна страница, которая постоянно взаимодействует с пользователем, динамически переписывая текущую страницу, а не загружая целые новые страницы с сервера

# Преимущества Single Page Applications

- Доступность. Можно получить моментальный доступ к функционалу с любого типа устройства без проблем с совместимостью, объемом памяти, мощностями или временем на установку.

- Универсальность. Использовать софт можно практически с любого устройства, если на нем есть доступ к интернету. Если при разработке интерфейса учитывались различные разрешения 
экрана, то использовать SPA одинаково удобно и с ПК и со смартфона.

- Возможность задействовать большие объемы данных. Размер приложения и используемых им данных не ограничен памятью устройства.

- Скорость. Одна страницасо всем необходимым не только экономит время на повторную загрузку данных, но и повышает производительность работы.

- Возможности разработки. Разработчикам доступны фреймворки, которые упрощают создание архитектуры проекта и предоставляют немало готовых элементов для работы.

# Недостатки SPA

- Трудности с SEO. Особенности SPA усложняют или делают невозможным процесс индексации поисковыми системами всех модулей приложения. Это может вызвать трудности с оптимизацией.

- Не работает у пользователей с отключенной поддержкой JS. Многие отключают отображение JS-элементов у себя в браузерах, а Single Page Application использует их в работе, поэтому может не работать.

# Списки и ключи

Сначала давайте вспомним, как работать со списками в JavaScript.

```
const arr = [1,2,3,4];
const newArr = arr.map(item => item + 1);

console.log(newArr); // [2,3,4,5]

```

В React преобразование массивов в список элементов выглядит похожим образом.


# Рендер нескольких компонентов

Вы можете создать коллекцию элементов и встроить её в JSX с помощью фигурных скобок {}.

К примеру

```
class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a','b','c','d'];
        return arr.map(letter => {
            return (
                <span>{letter}</span>
            )
        })
    }
    
    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

Когда вы запустите данный код, то увидите предупреждение о том, что у каждого элемента массива должен быть ключ (key). «Ключ» — это специальный строковый атрибут, который нужно указывать при создании списка элементов

Чтобы исправить проблему с неуказанными ключами, добавим каждому элементу в списке атрибут key.

```
class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a','b','c','d'];
        return arr.map(letter => {
            return (
                <span key={letter}>{letter}</span>
            )
        })
    }
    
    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

# Ключи

Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. 

Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. 

Чаще всего вы будете использовать ID из ваших данных как ключи:

Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ:

```
class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a','b','c','d'];
        return arr.map((letter, index) => {
            return (
                <span key={index}>{letter}</span>
            )
        })
    }
    
    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

# Извлечение компонентов с ключами

Ключи нужно определять непосредственно внутри массивов. (внутри перебора)

```
./Span.jsx

class Span extends Component {
    render() {
        return (
            <span>{this.props.value}</span> // ! key передаем не сюда !
        )
    }
}

```

```
./Test.jsx

class Test extends React.Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    spawnItems = () => {
        const arr = ['a', 'b', 'c', 'd'];
        return arr.map((letter, index) => {
            return <Span value={letter} key={index} /> // ! Key нужен тут !
        })
    }

    render() {
        return (
            <div>
                {this.spawnItems()}
            </div>
        );
    }
}

```

!!!! Ключи должны быть уникальными !!!!


# Роутинг ( Маршрутизация )

Для чего нужна маршрутизация?

В любом реальном веб-приложении нужны маршруты, и приложение React не исключение. 

Пользователь должен видеть, где он находится в приложении в любой момент времени. 

А видит он свое текущее местоположение в адресной строке браузера. 

Следовательно приложение должно уметь сопоставлять определённый URL с соответствующей ему страницей. 

То есть, если мы введём в адресную строку например https://test/test1, то приложение должно направить нас на страницу списка приёмов, но не на какую-либо другую.

Также должна работать история. 

То есть когда пользователь кликает на стрелку "Назад" в браузере, приложение должно направить нас на предыдущую страницу.

Сам по себе React не предоставляет такой возможности, это задача специальных библиотек. 

Как правило, используя API такой библиотеки мы подключаем компоненты страниц нашего положения, сопоставляя их с определёнными путями. 

После этого, переходя с одной страницы на другую мы будем видеть в адресной строке, как изменяется текущий путь.

На данный момент есть несколько популярных библиотек для маршрутизации: react-router, router5, aviator и пр. 

Мы будем использовать **react-router**

# Библиотека react-router

Эта библиотека популярна, довольна проста в использовании и обладает хорошей документацией.

Она предоставляет такие возможности как:

- Навигация по клику (компонент <Link>)

- Перенаправление (компонент <Redirect>)

- Маршрутизация (компонент Route)

- История (свойство history)

# Установка

React Router был разбит на 3 пакета:

- react-router

- router-dom

- react-router-native

Мы будем создавать сайт который будет отображаться в браузере, поэтому нам следует использовать react-router-dom. react-router-dom экспортирует из react-router все функции поэтому нам нужно установить только react-router-dom.

```
npm install --save react-router-dom

```

# Router

При старте проекта вам нужно определить какой тип роутера использовать. 

Для браузерных проектов есть BrowserRouter и HashRouter компоненты. 

BrowserRouter — следует использовать когда вы обрабатываете на сервере динамические запросы, а HashRouter используйте когда у вас статический веб сайт.

Обычно предпочтительнее использовать BrowserRouter, но если ваш сайт расположен на статическом сервере(от перев. как github pages), то использовать HashRouter это хорошее решение проблемы.

Если проект предполагает использование бекенда, то будем использовать BrowserRouter.

# История — History

Каждый Router создает объект history который хранит путь к текущему location и перерисовывает интерфейс сайта когда происходят какие то изменения пути.

# Рендеринг Router

Компонент Router ожидает только один элемент в качестве дочернего. 




