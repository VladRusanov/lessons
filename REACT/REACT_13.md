# JSON Web Tokens (JWT)

JSON Web Token (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON. 

Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях.

В простом понимании — это строка в специальном формате, которая содержит данные, например, ID и имя зарегистрированного пользователя. 

Она передается при каждом запросе на сервер, когда необходимо идентифицировать и понять, кто прислал этот запрос.

# Для дальнейших разборов будет использован токен:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9.E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0

```

После того, как посетитель прошел авторизацию в нашей системе, указав свой логин и пароль, система выдает ему 2 токена: access token и refresh токен.

После чего посетитель, когда хочет получить с сервера данные, например, свой профиль, вместе с запросом он передает Access токен, как на примере выше.

Токен разделен на три основные группы: заголовок, полезные данные и сигнатура, разделенные между собой точкой.

# Заголовок

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 - это первая часть токена - есть заголовок. Она закодирована в Base64 и если её раскодировать, получим строку:

```
{ 
  "alg": "HS256", 
  "typ": "JWT"
}

```

Это можно проверить прям в браузере, выполнив в консоле или js коде:

```
const header = atob('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9');
console.log(header);

```

- typ - это наш тип токена JWT. 

- Alg - алгоритм шифрования HMAC-SHA256. Их может быть несколько


# PAYLOAD или полезные данные


Вторым блоком идет eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9


Это есть полезные данные, так же закодированные в Base64. После раскодирования получим:

```
{ 
  "user_id":1, 
  "exp":1581357039
}

```
Данные могут быть любыми. 

Главное, чтобы по ним можно было идентифицировать пользователя. 

В нашем случае - это user_id и exp - время окончания действия текущего токена.

Поскольку необходимо ограничивать токен по времени, поле exp обязательно. По нему можно проверить, актуален ли токен или нет.

# Сигнатура

Последняя часть токена - наиболее важная. У нас это E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0

Как вы уже могли заметить - первые данные передаются практически в открытом виде и раскодировать их может любой. 

Но шифровать их нет необходимости. Цель токена - подтвердить, что эти данные не были изменены. 

Вот для этих целей и выступает сигнатура. И чтобы её сгенерировать нужен приватный ключ. 

Ну или некая секретная фраза, которая находится только на сервере. 

Только с помощью этого ключа мы можем создать сигнатуру и проверить, что она была создана именно с помощью его.

# Она получается примерно следующим образом:


Берем заголовок, например {"alg":"HS256","typ":"JWT"} и кодируем его в base64, получаем ту самую часть eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9

Тоже самое проделываем с данными eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9

После этого склеиваем их и получаем eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9

Далее эти данные шифруем с помощью нашего алгоритма HMAC-SHA256 и ключа.

# Условный псевдокод:

```
const header = '{"alg":"HS256","typ":"JWT"}' // строка
const payload = '{"user_id":1,"exp":1581357039}' // строка
// кодируем заголовок и данные в base64
const headerBase64 = base64urlEncode(header)
const payloadBase64 = base64urlEncode(payload)
// склеиваем точкой полученные строки
const data = headerBase64 + '.' + payloadBase64
// кодируем алгоритмом шифрования нашим ключем шифрования
const secret = '123456'
const sig = HMAC-SHA256(data, secret)
// и, наконец, получаем окончательный токен
const jwt = data + '.' + sig

```

# Refresh token

Основной токен, про который шла речь выше, обычно имеет короткий срок жизни - 15-30 минут. Больше давать не стоит.

Как только время выйдет, пользователю снова придется проходить авторизацию. 

Так вот чтобы этого избежать, существует Refresh токен. С помощью него можно продлить Access токен.

В действительности, Refresh токен обязательно должен быть одноразовым. 

Его задача - получить новую пару токенов. Как только это было сделано, предыдущий токен будет считаться недействительным.

У него, обычно, нет какой-то структуры и это может быть некая случайная строка

Генерируется Access токен и после случайная строка, например T6cjEbghMZmybUd_fhE

С нашего нового Access токена eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9.E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0 беру последние шесть знаков, получаю Ed4wF0

Склеиваю и получаю рефреш токен T6cjEbghMZmybUd_fhEEd4wF0

# Библиотека jsonwebtoken

Эта библиотека поможет нам работать с токеном

```
npm i jsonwebtoken

```

```
import jwt from 'jsonwebtoken';

const token = localStorage.getItem('accessToken');
const user = jwt.decode(token); // декодируем токен и получаем данные

```

К нашему примеру

```
import jwt from 'jsonwebtoken';

const token = localStorage.getItem('accessToken');
const user = jwt.decode('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9.E4FNMef6tkjIsf7paNrWZnB88c3WyIfjONzAeEd4wF0');

```

Получаем 

```
{user_id: 1, exp: 1581357039}

```

Чтобы создать токен

```
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');

```


Еще пример на создание 

```
const older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh'); // iat - время токена
const token = jwt.decode(older_token)
console.log('test: ', test);

```
