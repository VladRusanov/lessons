# Map и Set

Сейчас мы знаем о следующих сложных структурах данных:

Объекты для хранения именованных коллекций.
Массивы для хранения упорядоченных коллекций.

Но этого не всегда достаточно для решения повседневных задач. Поэтому также существуют Map и Set.

# Map

Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

# Методы и свойства:

- new Map() – создаёт коллекцию.

- map.set(key, value) – записывает по ключу key значение value.

- map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.

- map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.

- map.delete(key) – удаляет элемент по ключу key.

- map.clear() – очищает коллекцию от всех элементов.

- map.size – возвращает текущее количество элементов.


# Например:

```
let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3

```

Как мы видим, в отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.

# Map может использовать объекты в качестве ключей.

Например:

```
let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123

```

# Попробуем заменить Map на Object в примере выше:

```
let john = { name: "John" };

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[john] = 123; // возьмём объект john как ключ

// Вот как это было записано!
alert( visitsCountObj["[object Object]"] ); // 123

```

# Цепочка вызовов

Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:

```
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");

```

# Перебор Map

Для перебора коллекции Map есть 3 метода:

-map.keys() – возвращает итерируемый объект по ключам,

-map.values() – возвращает итерируемый объект по значениям,

-map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

Например:

```
let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
  alert(entry); // огурец,500 (и так далее)
}

```

При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь

```
// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1

```

Пример

```
let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

console.log(map.get('name')); // John

```

# Object.entries: Map из Object

ы только что видели, как создать Map из обычного объекта при помощи Object.entries(obj).

Есть метод Object.fromEntries, который делает противоположное: получив массив пар вида [ключ, значение], он создаёт из них объект:

```
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2

```

Мы можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

К примеру, у нас данные в Map, но их нужно передать в сторонний код, который ожидает обычный объект.

Вот как это сделать:

```
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2

```

Вызов map.entries() возвращает массив пар ключ/значение, как раз в нужном формате для Object.fromEntries.

# Set

Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

- new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.

- set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set

- set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false

- set.has(value) – возвращает true, если значение присутствует в множестве, иначе false

- set.clear() – удаляет все имеющиеся значения

- set.size – возвращает количество элементов в множестве


Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит, 

за счёт этого как раз и получается, что каждое значение появляется один раз.


Например, мы ожидаем посетителей, и нам необходимо составить их список. 

Но повторные визиты не должны приводить к дубликатам. 

Каждый посетитель должен появиться в списке только один раз.

Множество Set – как раз то, что нужно для этого:

```
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // John (потом Pete и Mary)
}

```


# Перебор объекта Set

Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:

```
let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});

```

Заметим забавную вещь. 

Функция в forEach у Set имеет 3 аргумента: значение value, потом снова то же самое значение valueAgain, и только потом целевой объект. 

Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. 

Выглядит немного странно, но в некоторых случаях может помочь легко заменить Map на Set и наоборот.


# Set имеет те же встроенные методы, что и Map:


- set.values() – возвращает перебираемый объект для значений,

- set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,

- set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


# Таска

Сделайте функцию, которая будет фильтровать массив (оставит только уникальные значения)

```
function unique(arr) {
  return Array.from(new Set(arr));
}

```


